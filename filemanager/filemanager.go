package filemanager

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	cp "github.com/otiai10/copy"

	"github.com/moond4rk/hackbrowserdata/log"
	"github.com/moond4rk/hackbrowserdata/profile"
)

// FileManager manages temporary file operations for data extraction.
type FileManager struct {
	// TempDir is the path to the temporary directory.
	TempDir string
}

// defaultDirPattern is the default pattern used for generating temporary directory names.
const defaultDirPattern = "hackbrowserdata"

// NewFileManager creates a new instance of FileManager with a unique temporary directory.
func NewFileManager() (*FileManager, error) {
	baseTempDir := os.TempDir()
	tempDir, err := os.MkdirTemp(baseTempDir, defaultDirPattern)
	if err != nil {
		return nil, fmt.Errorf("failed to create temporary directory: %w", err)
	}
	return &FileManager{TempDir: tempDir}, nil
}

func (fm *FileManager) CopyProfiles(originalProfiles profile.Profiles) (profile.Profiles, error) {
	newProfiles := profile.NewProfiles()
	for profileName, originalProfile := range originalProfiles {
		newProfile, err := fm.CopyProfile(originalProfile)
		// TODO: Handle multi error
		if err != nil {
			return nil, fmt.Errorf("failed to copy profile %s: %w", profileName, err)
		}
		newProfiles[profileName] = newProfile
	}
	return newProfiles, nil
}

// CopyProfile copies the profile to a temporary directory and returns the new profile.
// TODO: Handle multi error
func (fm *FileManager) CopyProfile(originalProfile *profile.Profile) (*profile.Profile, error) {
	newProfile := profile.NewProfile(originalProfile.Name)
	newProfile.BrowserType = originalProfile.BrowserType

	if originalProfile.MasterKeyPath != "" {
		copiedMasterKeyPath, err := fm.CopyToTemp(originalProfile.Name, originalProfile.MasterKeyPath)
		if err != nil {
			return nil, fmt.Errorf("failed to copy master key: %w", err)
		}
		newProfile.MasterKeyPath = copiedMasterKeyPath
	}

	for dataType, paths := range originalProfile.DataFilePath {
		for _, originalPath := range paths {
			copiedPath, err := fm.CopyToTemp(originalProfile.Name, originalPath)
			if err != nil {
				log.Errorf("failed to copy data file %s: %v", originalPath, err)
				continue
				// return nil, fmt.Errorf("failed to copy data file %s: %w", originalPath, err)
			}
			newProfile.DataFilePath[dataType] = append(newProfile.DataFilePath[dataType], copiedPath)
		}
	}

	return newProfile, nil
}

// CopyToTemp copies the specified file or directory to temporary directory and returns its new path.
func (fm *FileManager) CopyToTemp(baseName, originalPath string) (string, error) {
	stat, err := os.Stat(originalPath)
	if err != nil {
		return "", fmt.Errorf("error accessing path %s: %w", originalPath, err)
	}

	// unique target filepath is generated by appending the current time in nanoseconds to the original filename
	// such is profileName-<originalFilename>-<currentUnixNano>.<ext>
	timestampSuffix := fmt.Sprintf("%d", time.Now().UnixNano())
	targetFilename := fmt.Sprintf("%s-%s-%s", baseName, filepath.Base(originalPath), timestampSuffix)
	targetPath := filepath.Join(fm.TempDir, targetFilename)

	if stat.IsDir() {
		// skip copying the directory if it is a lock file, mostly used in leveldb
		err = fm.CopyDir(originalPath, targetPath, "lock")
	} else {
		err = fm.CopyFile(originalPath, targetPath)
	}

	if err != nil {
		return "", fmt.Errorf("failed to copy %s to %s: %w", originalPath, targetPath, err)
	}

	return targetPath, nil
}

// Cleanup removes the temporary directory and all its contents.
func (fm *FileManager) Cleanup() error {
	return os.RemoveAll(fm.TempDir)
}

// CopyDir copies the directory from the source to the destination
// skip the file if you don't want to copy
func (fm *FileManager) CopyDir(src, dst, skip string) error {
	s := cp.Options{Skip: func(info os.FileInfo, src, dst string) (bool, error) {
		return strings.HasSuffix(strings.ToLower(src), skip), nil
	}}
	return cp.Copy(src, dst, s)
}

// CopyFile copies the file from the source to the destination.
// Here `dst` is expected to be the complete path including the filename where the content is to be written.
func (fm *FileManager) CopyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	srcInfo, err := srcFile.Stat()
	if err != nil {
		return err
	}

	dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, srcInfo.Mode())
	if err != nil {
		return err
	}
	defer dstFile.Close()

	if _, err := io.Copy(dstFile, srcFile); err != nil {
		return err
	}
	return nil
}
